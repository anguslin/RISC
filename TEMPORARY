//This verilog code is to implement the datapath for a simple RISC machine

module datapath(clk, readnum, vsel, loada, loadb, shift, asel, bsel, ALUop, loadc, loads, writenum, write, datapath_in, status, datapath_out);

`define WIDTH 16
`define STATUSWIDTH 1

//
//Reading and Registering
//

input clk, loada, loadb, write;
input [2:0] readnum;
reg [15:0] reg0, reg1, reg2, reg3, reg4 ,reg5 ,reg6 ,reg7;
wire [15:0] A, B;
reg [15:0] data_out;

always @(*) begin
	case(readnum)
	3'b000: data_out= write? data_out: reg0; //if write is 0 and readnum is 000 take the value in register 0 and put in data_out
	3'b001: data_out= write? data_out: reg1; //if write is 0 and readnum is 001 take the value in register 1 and put in data_out
	3'b010: data_out= write? data_out: reg2; //if write is 0 and readnum is 010 take the value in register 2 and put in data_out
	3'b011: data_out= write? data_out: reg3; //if write is 0 and readnum is 011 take the value in register 3 and put in data_out
	3'b100: data_out= write? data_out: reg4; //if write is 0 and readnum is 100 take the value in register 4 and put in data_out
	3'b101: data_out= write? data_out: reg5; //if write is 0 and readnum is 101 take the value in register 5 and put in data_out
	3'b110: data_out= write? data_out: reg6; //if write is 0 and readnum is 110 take the value in register 6 and put in data_out
	3'b111: data_out= write? data_out: reg7; //if write is 0 and readnum is 111 take the value in register 7 and put in data_out
	default: data_out= {`WIDTH{1'bx}}; //set everything to x for default
	endcase
end

//Clock Updates for A and B depending on clock and loada and loadb
DFlipFlopAllow #(`WIDTH) loadaData(clk, loada, data_out, A); //A is running on a clock
DFlipFlopAllow #(`WIDTH) loadbData(clk, loadb, data_out, B); //B is running on a clock



//
//Computation Stage
//

input [1:0] shift, ALUop;
input asel, bsel, loadc, loads;
input [15:0] datapath_in;
reg [15:0] BShift, ALUComputedValue, C; 
wire [15:0] Ain, Bin;
output status;
reg statusComputed;

//Operations for Computation Stage

//if asel is 1 set Ain= A value else set Ain= 0s 
assign Ain= asel? A: {`WIDTH{1'b0}}; 

//if bsel is 0 set Bin= to shifted B value else set Bin= to 11bits 0s + first 5 bits of datapath_in
assign Bin= bsel? {{11{1'b0}},datapath_in[4:0]}: BShift; 

//Clock updates for status and C
DFlipFlopAllow #(`STATUSWIDTH) loadStatusData(clk, loads, statusComputed, status); 	//status is running on a clock
DFlipFlopAllow #(`WIDTH) loadCData(clk, loadc, ALUComputedValue, C); 		//C is running on a cock


//Values for ALU and status
always @(*) begin
	case(ALUComputedValue)
		16'b0000000000000000: statusComputed= 1; 	//if all 0 then status value to be updated will be 0 
		default: statusComputed= 0;			//if not all 0 then status value to be updated will be 1
	endcase
end

//Shift operations
always @(*) begin
	case(shift)
	2'b00: BShift= B;			//if operation is 00 output is B
	2'b01: BShift= {B[14:0], 1'b0};		//if operation is 01 output is B shifted left one and right bit becomes 0 
	2'b10: BShift= {1'b0, B[15:1]} ;	//if operation is 10 output is B shifted right one and left bit becomes 0 
	2'b11: BShift= {B[15], B[15:1]};	//if operation is 11 output is B shifted right one and left bit becomes b[15]
	default: BShift= {`WIDTH{1'bx}};		//default all to x
	endcase
end

//ALUop operations
always @(*) begin
	case(ALUop)
	2'b00: ALUComputedValue= Ain + Bin;		//if operation is 00 output is Ain + Bin
	2'b01: ALUComputedValue= Ain - Bin;		//if operation is 01 output is Ain - Bin
	2'b10: ALUComputedValue= Ain & Bin;		//if operation is 10 output is Ain AND Bin
	2'b11: ALUComputedValue= ~Bin;			//if operation is 11 output is not Bin
	default: ALUComputedValue= {`WIDTH{1'bx}};	//default all x
	endcase
end



//
//Writing values into register and Writing Back
//

input vsel;
input [2:0] writenum;
output [15:0] datapath_out;
wire [15:0] data_in;
reg [15:0] reg0ToUpdate, reg1ToUpdate, reg2ToUpdate, reg3ToUpdate, reg4ToUpdate, reg5ToUpdate, reg6ToUpdate, reg7ToUpdate;
//Operations for Writing Back values and Registering writing

//Update based on clock
always @(*) begin
	case(writenum)
	3'b000: reg0ToUpdate= write? data_in: reg0ToUpdate; 	//if write is 1 and writenum is 000 put value in data_in and put in reg0
	3'b001: reg1ToUpdate= write? data_in: reg1ToUpdate; 	//if write is 1 and writenum is 001 put value in data_in and put in reg1
	3'b010: reg2ToUpdate= write? data_in: reg2ToUpdate; 	//if write is 1 and writenum is 010 put value in data_in and put in reg2
	3'b011: reg3ToUpdate= write? data_in: reg3ToUpdate; 	//if write is 1 and writenum is 011 put value in data_in and put in reg3
	3'b100: reg4ToUpdate= write? data_in: reg4ToUpdate;	//if write is 1 and writenum is 100 put value in data_in and put in reg4
	3'b101: reg5ToUpdate= write? data_in: reg5ToUpdate;	//if write is 1 and writenum is 101 put value in data_in and put in reg5
	3'b110: reg6ToUpdate= write? data_in: reg6ToUpdate;	//if write is 1 and writenum is 110 put value in data_in and put in reg6
	3'b111: reg7ToUpdate= write? data_in: reg7ToUpdate; 	//if write is 1 and writenum is 111 put value in data_in and put in reg7
	default: {reg0ToUpdate,reg1ToUpdate,reg2ToUpdate,reg3ToUpdate,reg4ToUpdate,reg5ToUpdate,reg6ToUpdate,reg7ToUpdate}= {112{1'bx}};	//default all x
	endcase
end

//Update registers on a clock
DFlipFlop #(`WIDTH) loadreg0Data(clk, reg0ToUpdate, reg0);
DFlipFlop #(`WIDTH) loadreg1Data(clk, reg1ToUpdate, reg1);
DFlipFlop #(`WIDTH) loadreg2Data(clk, reg2ToUpdate, reg2);
DFlipFlop #(`WIDTH) loadreg3Data(clk, reg3ToUpdate, reg3);
DFlipFlop #(`WIDTH) loadreg4Data(clk, reg4ToUpdate, reg4);
DFlipFlop #(`WIDTH) loadreg5Data(clk, reg5ToUpdate, reg5);
DFlipFlop #(`WIDTH) loadreg6Data(clk, reg6ToUpdate, reg6);
DFlipFlop #(`WIDTH) loadreg7Data(clk, reg7ToUpdate, reg7);


//if vsel is 1 input values from datapath_in to data_in else input values from datapath_out to data_in
assign data_in= vsel? datapath_in: datapath_out; 

//put value of C into datapath_out
assign datapath_out= C; 		
endmodule
